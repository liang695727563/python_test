#coding=utf-8

# 冒泡排序算法由来：这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端(升序或降序排列)，就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”

# 从前到后(即从下标较小的元素开始) 依次比较相邻元素的值，若发现比后一个值大则交换位置，使值较大的元素逐渐从前移向后部。

# 假设有一个列表 [29 ,12 ,19 ,37 ,14] 想按升序排列

# 第一轮：初始列表为 [29 ,12 ,19 ,37 ,14]
# 比较 29 > 12 交换位置：[12,29,19,37,14]
# 比较 29 > 19 交换位置：[12,19,29,37,14]
# 比较 29 > 37 不大于，不交换：列表同上不变
# 比较 37 > 14 交换位置：[12,19,29,14,37]
# 第二轮：列表继承上一轮为 [12,19,29,14,37]
# 比较 12 > 19 不大于，不交换：列表同上不变
# 比较 19 > 29 不大于，不交换：列表同上不变
# 比较 29 > 14 交换位置：[12,19,14,29,37]
# 第三轮：列表继承上一轮为 [12,19,14,29,37]
# 比较 12 > 19 不大于，不交换：列表同上不变
# 比较 19 > 14 交换位置：[12,14,19,29,37]
# 第四轮：列表继承上一轮为 [12,14,19,29,37]
# 比较 12 > 14 不大于，不交换：列表同上不变

# 列表排序完成：[12,14,19,29,37]

import numpy as np

pop_list = np.random.randint(100, size=6)

count = len(pop_list)
print "没有排序之前的列表", pop_list

for i in range(count-1):
    for j in range(count-i-1):
        if pop_list[j] > pop_list[j + 1]:   # 如果要降序的就是改成 < 号
            pop_list[j],pop_list[j+1] = pop_list[j+1], pop_list[j]
print "排好序后的列表为", pop_list